<!DOCTYPE html>
<html lang="en">
<head>
    
    <link rel="stylesheet" href="contenido.css">

    <title>Curso Fundamentos de la programaci칩n  </title>

</head>

<body>
    
        <div class="bannercursofundamentosdelaprogramaci칩n" id="i">


        <h2>Curso Fundamentos de la programaci칩n </h2>
        
        </div>
<!--MAIN CONTENIDO-->


<div class="contenedor">

<ol class="cursofundamentosdelaprogramaci칩n">
    
    <li class="bt n0"><a href="index.html"><img src="iconos/hacia_atras.png" alt=""></a></li>
    <li class="bt n1"><a href="#1">MODULO 1</a></li>
    <li class="bt n2"><a href="#2">MODULO 2</a></li>
    <li class="bt n3"><a href="#3">MODULO 3</a></li>
    <li class="bt n4"><a href="#4">ALGORITMOS Y COMPLEJIDAD</a></li>
    <li class="bt n5"><a href="#5">ALGORITMOS DE ORDENAMIENTO</a></li>
    <li class="bt n6"><a href="#6"></a></li>
    <li class="bt n7"><a href="#7"></a></li>
    <li class="bt n8"><a href="#8"></a></li>
    <li class="bt n9"><a href="#9"></a></li>
    <li class="bt n10"><a href="#10"></a></li>

</ol>

</div>

<!--MAIN CONTENIDO-->
<main>

    <div class="tema" id="1">

        <h3><a href="#i"><img class="it" src="*/iconos/github.png" alt="">INICIO:</a>MODULO 1</h3>

        <pre>

            <b>쯇or qu칠 son importantes los fundamentos de programaci칩n?</b>

            Fundamento se refiere al origen, conocimientos bases m칠todos y herramientas
            No se necesita experiencia, pero si conocer conceptos y herramientas.

            <b>Objetivos de los fundamentos.</b>

            Proporciona familiaridad con los conceptos b치sicos de construcci칩n de 
            programas para computadores que son comunes en la mayoria de los lenguajes
            de programaci칩n.



            <b>쯈UE ES UN PROGRAMA?</b>

            Es una secuancia de instrucciones.

            Las instrucciones del programa se desarrollan en el procesador central.
            todo el conjunto de instrucciones se encuentran encaminadas para dar solucion a 
            un problema o tarea en especifico.
            
            sistema estructurado de comunicaci칩n.

            lespermite a las personas o programador dar instrucciones especificas al dispositivo
            a travez del software, con la finalidad de lograr determinados objetivos.


            <b>QUE ES UN LENGUAJE DE PROGRAMACION.</b>

            Son lenguajes que comunican al hombre con la maquinay los sistemas digitales, 
            exiten variedades de lenguajes de programacion que todo profecional 
            de ingenieria en sistemas y areas a fines debe dominar como java,python,SCala,y Rust, 
            entre otros.


            <b>Sistemas binarios:</b>

            ES uno de los sistemas que se usan en las computadorasbasado en un sitema
            num칠rico binario, en donde solo hay dos estados posibles:apagado y encendido,
            generalmente simbolizados por 0 y 1.


            Este cero y uno se denomina bit se le define como la minima unidad de informacion.
            La base del sistema binario es 1024, se conoce entonces una tabla de unidades y medidas.

            <img src="imagenes_git/fundamentos1.png" alt="">


            <b>Frond-end o Analizador</b>

            Se encarga de realizar el analisis del codigo fuente a compilar
            lo valida e interactua con el usuario, suele ser independiente de la 
            plataforma de trabajo.

            <b>Back-end o Generador </b>
            
            Es la parte del compilador que apartir de los resultados del analisis
            se encarga de generar el codigo para la maquina segun la plataforma
            especifica.


            <b>Fases del analisis de un compilador</b>

            *An치lisis l칠xico.

                Reconocimiento de los elementos del lenguaje agrupados en componentes
                llamados tokens.

            *Analisis sintatico.
                
                los componentes lexicos se agrupan gerargicamente en frases gramaticales
                para analizar su extructura con reglas y patrones especificos.

            *An치lisis semantico

                se utiliza la extructura gerargica determinada por la fase de analisis 
                sintatico para identificar eventuales errores semanticos.


            *Generacion del codigo intermedio.

                despues de las fases de analisis se genera una representacion de codigo 
                intermedio para una maquina abstracta.

            *Optimizacion del codigo
            
                se mejora la representacion del codigo intermedio para obtener un  codigo.



            <b>LENGUAJES COMPILADOS</b>

            Traductores que generan codigo de maquina apartir de un codigo fuente.

            <b>LENGUAJES INTERPRETADOS</b>

            Ejecutores del paso a paso del codigo fuente, donde no se lleva acabo una 
            traduccion y preejecucio.


            <b>CONCLUCION:</b>

            Los programas compilados a codigo nativo en tiempo de compilacion tienden 
            a ser mas rapidos que los traducidos en tiempo de ejecucio, debido a la sobrecarga 
            del proceso de traduccion. Sin embargo, las nuevas tecnologias con la compilacion en
            tiempo de ejecucion, y mejoras generales en el proceso de traduccion estan 
            empezando a reducir esta brecha. En algun punto intermedio, tiende a ser mas eficiente 
            la solucion mixta usando BYTECODE.



            <b>LENGUAJES INTERPRETADOS</b>

            En ciencias de la computacion, interprete o interpretador es un programa informatico
            capaz de analizar y ejecutar otros programas, los interpretes se diferencian de los compiladores
            o de los ensambladores en que mientras estos traducen un programa desde su descripcion
            en un lenguaje de programacion al codigo maquina del sistema,los interpretes solo realizan 
            la traduccion a medida de que sea necesaria,t칤picamente, instruccion por instruccion y normalmente
            no guardan el resultado de dicha traduccion.


        </pre>


    </div>
    
    <div class="tema" id="2">

        <h3><a href="#i"><img class="it" src="*/iconos/github.png" alt="">INICIO:</a>MODULO 2</h3>

        <pre>

        <b>DESARROLLO WEB</b>

         
                <img src="imagenes_Linux/fundamentos1.jpg" alt="">

                1. 游눹 Desarrollo web
            La web es todo lo que se puede ejecutar en un navegador. 쯏 qu칠 es un navegador? 
            Son programas como Chrome, Opera, Microsoft Edge que nos permiten acceder a 
            sitios como Twitter, Facebook, YouTube, Slack, etc.
            Podr칤amos dividir el desarrollo web en 2 partes:

            1. Sitios web: Son solo p치ginas web informativas. Su funci칩n es meramente informar 
            al usuario, sea sobre un negocio, escuela, etc. Se puede utilizar un CMS como 
            WordPress para crearlos.

            2. Aplicaciones web: Es una aplicaci칩n completa y contiene una l칩gica compleja, por 
            ejemplo: YouTube es una aplicaci칩n web, se pueden realizar funciones como 
            guardar v칤deos, crear una transmisi칩n, marcar favoritos, etc.
            El desarrollo web se podr칤a divide en backend y frontend. De manera simple 
            podemos decir que el backend es la parte se encarga del lado del servidor (No es 
            visible), y el frontend se encarga del lado del cliente(Lo puedes observar desde tu 
            pantalla).
            En esta infograf칤a puedes ver de todo lo que se encarga el Backend y Frontend en 
            una aplicaci칩n


        <b>DESARROLLO MOVIL</b>

            El desarrollo m칩vil es simples palabras es crear aplicaciones para tel칠fonos y estas 
            pueden funcionar en 2 sistemas operativos: Android de Google y iOS de Apple.
            En Android puedes desarrollar con lenguajes como Kotlin o Java, mientras que en 
            IOS est치 Swift. A este tipo de aplicaciones se les conoce como "aplicaciones 
            nativas", ya que se desarrollan espec칤ficamente en un sistema, esto quiere decir 
            que no van a funcionar en el otro, habr칤a que crear otra aplicaci칩n para ello. Esto 
            puede suponer un costo excesivo para las empresas, ya que habr칤a que hacer 2 
            aplicaciones.

            Pero, 쯤u칠 otras alternativas existen?

            1. Aplicaciones multiplataforma: En este tipo de aplicaciones solo se necesita 
            desarrollar una sola vez para funcionar en Android o iOS. Se pueden hacer 
            con React Native, Ionic, Xamarin o Flutter.

            2. Progressive Web Apps: Son aplicaciones intermedias entre web y m칩viles, que 
            simulan la experiencia de una aplicaci칩n nativa. Por ejemplo la aplicaci칩n de 
            EDteam para m칩viles es una PWA

                <img src="imagenes_Linux/fundamentos2.jpg" alt="">


        <b>DESARROLLO VIDEOJUEGOS</b>

            Ya todos los conocemos, tienen sus propias consolas, est치n en m칩viles, en 
            ordenadores y consolas. Su mundo es enorme, hay dise침adores, storytelling, 
            modelado de personajes. Entre los motores m치s importantes que puedes usar para 
            desarrollar videojuegos se encuentran, Unity 3D que utiliza C# y Unreal Engine que 
            usa C++
        
                <img src="imagenes_Linux/fundamentos3.jpg" alt="">



        <b>DESARROLLO REALIDAD VIRTUAL Y AUMENTADA</b>
        
            La realidad virtual es una inmersi칩n total, se suele utilizar un casco o lentes que 
            ocupa toda tu visi칩n, y con ello puedes transportarte a un mundo de ensue침o, hay 
            proyectos muy conocidos como Beat Saber y Half-Life: Alyx.

            Mientras que la realidad aumentada combina nuestra realidad con la virtual, un 
            ejemplo de ello es Pok칠mon GO o los filtros de Snapchat. 쯏 como funciona? Es 
            muy simple, solo se necesita un dispositivo que permita observar el entorno, y con 
            este mismo agregarle ese a침adido, por ejemplo con la c치mara del tel칠fono que 
            puedes a침adir efectos para las stories. Esta tecnolog칤a se puede trabajar con varios 
            lenguajes, tales como C#, Java, Javascript, Python, entre otros.

            Cabe mencionar que esta tecnolog칤a no est치 enfocada solamente en el 
            entretenimiento, sino que se puede aplicar en 치reas como la educaci칩n, medicina, 
            mec치nica, etc. Anteriormente existieron proyectos como Google Glass, que no 
            despeg칩 tanto como se esperaba y por su parte Microsoft sac칩 HoloLens

        <b>DESARROLLO APLICACIONES DE ESCRITORIO</b>
        
            Son aplicaciones que se instalan directamente en tu sistema operativo de 
            computadora sea Windows,Linux, Mac OS, por ejemplo: Adobe Premier, Office, un 
            editor de c칩digo, un IDE. Para desarrollar este tipo de aplicaciones se pueden 
            utilizar lenguajes como Java, C#, Python.

        <b>DESARROLLO SISTEMAS OPERATIVOS/EMDEDIDOS</b>

            Los sistemas operativos son justamente Windows, Linux, Android o IOS, es la capa 
            m치s baja de software que se comunica directamente con el hardware. Se suelen 
            usar lenguajes como Ensamblador o C para desarrollarlos.

            Mientras que los sistemas embebidos son programas electr칩nicos que realizan pocas 
            funciones y est치n dise침ados para cubrir necesidades espec칤ficas, casi siempre van 
            directamente en un chip; por ejemplo: las operaciones de una lavadora, un 
            refrigerador o alg칰n otro electrodom칠stico.

            Principalmente se desarrollan con Java o C. Tambi칠n se relaciona con temas como 
            Arduino, IoT, Raspberry, que se pueden programar con lenguajes como Python y 
            Javascript.

        


        <b>SEGURIDAD INFORMATICA</b>

            La seguridad inform치tica es tarea de todos, tanto de los programadores como de 
            los administradores de sistemas, y aunque no lo parezca el usuario como tal es el 
            eslab칩n m치s d칠bil. Por su parte la seguridad inform치tica se puede clasificar en 2 
            치reas:

            쮺u치les lenguajes necesitas conocer para entrar en el mundo de la seguridad 
            inform치tica? Principalmente Python, ya que te permite automatizar procesos, por 
            ejemplo podr칤as crear un script autom치tico que recorra un sitio para buscar 
            vulnerabilidades. Tambi칠n es bueno conocer sobre C, bash y los lenguajes en que 
            est치n basados las aplicaciones que vas a auditar, asimismo SQL para las bases de 
            datos


                <img src="imagenes_Linux/fundamentos4.jpg" alt="">


        <b>MACHINE LEARNING</b>

            B치sicamente consiste en ense침arle a las computadores a trav칠s de enormes 
            vol칰menes de datos, El papel de los programadores en este 치mbito es crear los 
            modelos, es decir la secuencia de pasos para que en Machine learning se pueda 
            crear algo, y as칤 encontrar patrones para poder predecir una acci칩n a futuro, por 
            ejemplo: en Netflix los usuarios reciben recomendaciones en base a las 
            pel칤culas/series que observaron previamente. 
            
            De igual manera se podr칤a hacer un 
            an치lisis de sentimientos en marketing, para conocer que tan a gusto se sienten los 
            usuarios con 'x' servicio, para as칤 poder fidelizarlos. Los 2 lenguajes m치s 
            importantes en el Machine learning son Python y R.


        <b>CLOUD COMPUTING</b>

            La nube es una red mundial de servidores que ofrecen servicios de 
            almacenamiento, bases de datos, redes, software, an치lisis e inteligencia a trav칠s de 
            internet. Esto les permite a las empresas y usuarios pagar solamente por lo que 
            usan, lo cual realmente es un beneficio enorme. Ya que no tienen que adquirir 
            equipos caros y todo lo que conllevan, sino que por un pago menor pueden optar 
            hasta por una supercomputadora

               <img src="imagenes_Linux/fundamentos5.jpg" alt="">

        </pre>

    </div>

    <div class="tema" id="3">

        <h3><a href="#i"><img class="it" src="*/iconos/github.png" alt="">INICIO:</a>MODULO 3</h3>

        <pre>


         <b>IDE Y DATOS</b>

         Integrated Development Environment (Entorno de Desarrollo Integrado)
         
         Entorno de desarrollo integrado

         Desarrollo de plaicaciones Web (DAW)
         Desarrolo de aplicaciones multiplataforma(DAM)
         
         Hacen que la tarea de programar sea mas sencilla


         <h3>COMPONENTES DE UN IDE</h3>

        <b>EDITOR DE FUENTE/CODIGO:</b>

        Editor de texto para trabajar en el codigo fuente de programas 
        informatico.

         <b>COMPILADOR</b>

         Encargado de traducir las instracciones en codigo fuente,
         escritas en lenguaje de programacion.


         <b>DEPURADOR</b>

         Programa que permite probar y encontrar errores.

         <b>REFACTORIZACION DE CODIGO:</b>

         Proceso en el que se recurre como el reformateo
         para mejorar el codigo fuente.

         <b>EJEMPLO DE IDE</b>  
        
        ECLIPCE:Entorno de desarrolo multiplataforma, desarrollado por IBM
        
        NETBEANS:Permite programar adroid con plugis,manejo automatico de la memoria

        VISUAL STUDIO CODE:Dupurar errores 



        <h3>DATOS Y CONSTANTES:</h3>
        
        <b>DATOS</b>

        Datos son representaciones simbolicas

        Sepueden representar en terminos de numeros (Enteros/Reales),Letras
        o elementos alfabeticos,elementos logicos.

        <b>DATOS VARIABLES</b>

        Entendiendo que variable es todo aquello que cambia, tecnicamente es una pocicion de memoria 
        donde se almacena informacion o datos.


        <b>DATOS CONSTANTES</b>

        A diferencia de la variable un dato constante no varia durante todo el programa,
        las constantes no se modifican.


       <h3>TIPOS DE DATOS</h3>
       
       
       <b>CARACTERES</b>

       Digitos individuales que se pueden representar mediante datos
       numericos (0-9),letras (a-z)u otros simbolos .(Especiales).

       <b>NUMERICOS</b>

       Pueden ser numeros Reales o enteros,Dependiendo de lo necesario.
       
       <b>BOOLEANOS</b>

       Representa valores logicos, como verdadero y falso.


       <b>FECHAS</b>

       Es un dato escecial donde almacena el calendario real
       de acuerdo al formato inclusive nos puede indicar el dia de la semana.


    <h3>DEFINICION DE VARIABLES:</h3>

    

        <li>Comienzan con una letra</li>

        <li>No deben tener espacion en blanco</li>

        <li>No pueden tener caracteres Especiales</li>

        <li>preferiblemente en minisculas ya que pueden existir 
            lenguajes que las direfencien</li>

        <li>Deben estar precedidas del signo igual</li>

        <li>Los textos van entre comillas con valor o sin valor.</li>

        <li>Los numeros se inician en cero para los enteros o 0.0 para los reales.</li>

        <li>Las contantes no modifican su valor.</li>

        <li>Se recomienda que se definan variables alusivas al tema.</li>

        <li>Cuando se realizan procesos o existan variables que hagan 
            algo diferente es importante documentar para que el compilador 
            no lo tenga en cuenta.</li>

        <li>El comentario se coloca //  o /* xxxx*/ En mas de una line de comandos.</li>

    

</pre>


    </div class="tema" id ="4">

    <h3><a href="#i"><img class="it" src="*/iconos/github.png" alt="">ALGORITMOS Y COMPLEJIDAD:</a></h3>



    <pre>

        <h3>BUSQUEDA LINEAL</h3>

        Es un metodo simple y facil de implementar para encontrar 
        elementos especificos de una lista o arreglos de datos.

        Busca un valor especifico de forma ordenada y secuancial.

        <b>EJEMPLO</b>

        def busqueda_lineal(lista,elemento):

        for i in range(len(lista)):
            if lista[i]==elemento:
                return i #retorno del indice
            return -1 #Si el elemento no esta en la lista.


        #Ejemplo con lista de numeros 

        numeros =[4,2,5,6,8,9]
        elemento_buscado= 2

        resultado=busqueda_lineal(numeros,elemento_buscado)


        if resultado =! -1:
            print(f"El elemento buscado {elemento_buscado} se encuentra en el indice {resultado}")
        else:
            print(f"El elemento{elemento_buscado} no se encuentra en la lista")


        <h3>BUSQUEDA BINARIA</h3>

        Algoritmo de busqueda eficiente, aplicado a listas ordenadas divide repetidamente la lista a la mitad
        reduciendo el numero de elementos a revisar.

        def busqueda_binaria(lista,elemento):
            low=0
            high=len(lista) -1

            while low <= high:
                mid=(low-high)//2
                if lista[mid]==elemento:
                    return mid
                elif lista[mid] < elemento:

                else: 
                    high ==mid -1
            return -1


        lista_ordenada=[1,2,3,4,5,6,7,8,9,10]
        elemento_buscado=7

        resultado=buscaqueda(lista_ordenada,elemento_buscado)

        if resultado = -1
            print(f"El elemento {elemento_buscado} se encuentra en el indice{resultado}")
        else:
            print(f"El elemento {elemento_buscado} no esta en la lista")

    <h3>BUSQUEDA POR INTERPOLACION</h3>

        Es un algoritmo de busqueda de elementos en listas ordenadas 
        de manera eficiente; utilizando la estimacion basada en la 
        distribucion uniforme de los valores en la lista.

        def busqueda_interpolacion(lista,elemento):
            low=0
            high=len(lista) - 1

            while low <= high and lista[low] <= elemento <=lista[high]
            # formula de interpolacion para busqueda binaria

                pos= low + (elemento-lista[low]* (hig-low))//(lista[higt]-lista[low])

                if lista[pos]==elemento:
                    return pos
                elif lista[pos]<elemento:
                    low = pos + 1
                else: 
                    high = pos -1
            return -1

        numeros_ordenados=[2,4,6,8,10,12,14,16,18,20]
        elemento_buscado=10
        resultado=busqueda_interpolacion(numeros_ordenados,elemento_buscado)

        if resultado != -1:
            print(f"El elemento {elemento_buscado} se encuentra en el indice{resultado}")
        else:
            print(f"El elemento {elemento_buscado} no esta en la lista")



    <h3>BUSQUEDA ARBOLES BINARIOS</h3>

    1.Comenzar en la raiz del ARBOLES
    2.Comparar el elemento con el valor en el nodo actual.
    3.si el valor es menor ,buscar en el subarbol derecho.

        <b>EJEMPLO :</b>

        class nodoABB

        def_init_(self,valor):

            self.valor=valor
            self.izquierda=none
            self.derecha=none

        def busqueda_abb(nodo,elemento)
            if nodo is none or novo.valor==elemento:
            return nodo
            
            # Si el valor es menor que el nodo actual, busca en el sub치rbol izquierdo
            if valor < nodo.valor:
                return buscar(nodo.izquierda, valor)
            
            # Si el valor es mayor, busca en el sub치rbol derecho
            return buscar(nodo.derecha, valor)
        
        <b># Ejemplo de uso:</b>

        # Construcci칩n del 치rbol binario de b칰squeda
        raiz = Nodo(15)
        raiz.izquierda = Nodo(10)
        raiz.derecha = Nodo(20)
        raiz.izquierda.izquierda = Nodo(8)
        raiz.izquierda.derecha = Nodo(12)
        raiz.derecha.izquierda = Nodo(17)
        raiz.derecha.derecha = Nodo(25)
        
        # Buscando el valor 12
        resultado = buscar(raiz, 12)
        if resultado:
            print("Valor encontrado:", resultado.valor)
        else:
            print("Valor no encontrado")



    </pre>

    </div>

    <div class="tema" id="5">

        <h3><a href="#i"><img class="it" src="*/iconos/github.png" alt="">ALGORITMOS DE ORDENAMIENTO:</a></h3>

        <pre>
            
            <h3>ORDENAMIENTO POR BURBUJA</h3>

            Recorre la lista de valores a ordenar , compara dos valores. si los dos elementos 
            estan bien ordenados continua de lo contrario mueve el mas grande al final.
            se repite el proceso hasta ordenar todo el arreglo.

            def busq(lista):
                    n=len(lista)

                    for i in range(n):
                        for j in range(0,n-i-1):
                            
                            if lista[j] > lista[j+1]:
                                lista[j] ,lista[j+1]=lista[j+1],lista[j]

                    return lista


            lista=[1,4,6,8,0,4,67,8,13,4,6,78,33,43,33,2221,11,1,1,1,1,1,2,3,3,4,5,6,]
            lista_ordenada=busq(lista)
            print(lista_ordenada)

            <h3>ORDENAMIENTO POR INSERCION</h3>

            Construye una lista ordenada de un elemento a la vez, en donde
            desplaza elementos mas grandes hacia la derecha mientras se muestra su 
            lugar correcto.

            *Para listas peque침as o parcialmente ordenadas.
            *menos oficiente que otros algoritmos.


            
            def lista_ordenada(arr):
                n=len(lista)

                for i in range(n):
                    clave = lista[i]
                    j=i-1
                    while j>=1 and lista[j]>clave:
                        lista[j+1]=lista[j]
                        j-=1
                    lista[j+1]=clave


                for i in range(n):
                    print(lista[i])

            lista=[2,3,5,7,2]

            resultado=lista_ordenada(lista)

        <h3>ORDENAMIENTO POR SELECCION</h3> 





            def selection_sort(arr):
        n = len(arr)
        
        for i in range(n):
            min_idx = i
            for j in range(i + 1, n):
                if arr[j] < arr[min_idx]:
                    min_idx = j
            
            arr[i], arr[min_idx] = arr[min_idx], arr[i]
        
        return arr

        # Ejemplo de uso
        arreglo = [64, 25, 12, 22, 11]
        print("Arreglo original:", arreglo)
        resultado = selection_sort(arreglo.copy())
        print("Arreglo ordenado:", resultado)


         <h3>ORDENAMIENTO POR MERGE SORT</h3> 

         <ul>
            <li>Eficiente</li>
            <li>Enfoque "Divide y venceras"</li>
            <li>Dividir</li>

         </ul>
        
        def merge_sort(arr):
            if len(arr) <= 1:
                return arr

            mid = len(arr) // 2
            left = merge_sort(arr[:mid])
            right = merge_sort(arr[mid:])

            return merge(left, right)

        def merge(left, right):
            result = []
            i = j = 0

            while i < len(left) and j < len(right):
                if left[i] < right[j]:
                    result.append(left[i])
                    i += 1
                else:
                    result.append(right[j])
                    j += 1

            return result + left[i:] + right[j:]

        # Ejemplo de uso
        arreglo = [38, 27, 43, 3, 9, 82, 10]
        print("Original:", arreglo)
        print("Ordenado:", merge_sort(arreglo))





            





        </pre>


    </div>

    <div class="tema" id="6">

    </div>

    <div class="tema" id="7">

    </div>

    <div class="tema" id="8">

    </div>

    <div class="tema" id="9">

    </div>

    <div class="tema" id="10">

    </div>

</main>

</body>

</html>